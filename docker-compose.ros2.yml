services:
#  # run with: pi_discovery_fix.xml
#  discovery-server:
#    image: adeept_raspclaws-raspclaws_ros2:latest
#    network_mode: host
#    container_name: discovery-server
#    command: >
#      bash -c "source /opt/ros/humble/setup.bash &&
#      fast-discovery-server -i 0 -l 0.0.0.0 -p 11811"
#    environment:
#      - FASTRTPS_DEFAULT_PROFILES_FILE=/ros2_ws/pi_discovery_fix.xml
#    restart: always
#    healthcheck:
#      test: ["CMD-SHELL", "pgrep -f 'fast-discovery-server' || exit 1"]
#      interval: 5s
#      timeout: 3s
#      retries: 3

  raspclaws_ros2:
    image: adeept_raspclaws-raspclaws_ros2:latest
    build:
      context: .
      dockerfile: Dockerfile.ros2
    network_mode: host
    container_name: raspclaws_ros2
    privileged: true  # <--- ERMÖGLICHT HARDWARE-ZUGRIFF (I2C)
    devices:
      - "/dev/i2c-1:/dev/i2c-1" # <--- DIREKTE MAP AN DIE SERVOS
    environment:
      - ROS_DOMAIN_ID=0
      #- FASTRTPS_DEFAULT_PROFILES_FILE=/ros2_ws/pi_discovery_fix.xml # <--- XML laden
      #- ROS_DISCOVERY_SERVER=127.0.0.1:11811
      #- PYTHONPATH=/ros2_ws:/ros2_ws/Server
      # ------------------
      # Wir löschen ROS_DISCOVERY_SERVER!
      # Stattdessen sagen wir ihm, er soll nur auf sich selbst und später auf den PC hören:
      - RMW_IMPLEMENTATION=rmw_fastrtps_cpp
      #- FASTRTPS_DEFAULT_PROFILES_FILE=/ros2_ws/pi_unicast_only.xml
      - PYTHONPATH=/ros2_ws:/ros2_ws/Server
      # ------------------
      # Wir sagen dem Pi, er soll den PC direkt anrufen:
      - ROS_STATIC_PEERS=192.168.2.121  # <--- HIER DEINE NOTIERTE IP EINTRAGEN
    #depends_on:
    #  discovery-server:
    #    condition: service_healthy  # Warte bis Server wirklich bereit ist
    volumes:
      - /home/pi/adeept_raspclaws:/ros2_ws
      - /dev:/dev  # Gibt dem Container direkten Zugriff auf Kamera und I2C
    command: >
      bash -c "source /opt/ros/humble/setup.bash && 
            python3 /ros2_ws/Server/ROSServer.py"
    restart: always

  #raspclaws_camera:
  #  image: adeept_raspclaws-raspclaws_ros2:latest  # Gleiches Image wie raspclaws_ros2
  #  build:
  # Camera container - starts both FPV.py (camera capture) and FPV_ROS2_simple.py (ROS2 publisher)
  # FPV.py handles camera hardware and provides frames via ZMQ
  # FPV_ROS2_simple.py reads those frames and publishes to ROS2 topics
  # Camera container - DISABLED
  #
  # ⚠️  libcamera and picamera2 are NOT available in standard Docker images
  #
  # Why? These packages are ONLY in Raspberry Pi OS repos, not in:
  # - Standard Debian (even Bookworm)
  # - Ubuntu (even 24.04)
  #
  # Solution: Run FPV.py directly on the Pi host (not in Docker)
  #
  # To use camera with ROS2:
  # 1. Run ROSServer in Docker (for robot control)
  # 2. Run FPV.py on host:  python3 Server/FPV.py
  # 3. Run FPV_ROS2_simple.py on host: python3 Server/FPV_ROS2_simple.py
  #
  # This way camera works (on host) and ROS2 works (in Docker).
  #
  # raspclaws_camera:
  #   [... commented out ...]

