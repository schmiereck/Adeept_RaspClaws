services:

  raspclaws_ros2:
    image: adeept_raspclaws-raspclaws_ros2:latest
    build:
      context: .
      dockerfile: Dockerfile.ros2
    network_mode: host
    container_name: raspclaws_ros2
    privileged: true  # <--- ERMÖGLICHT HARDWARE-ZUGRIFF (I2C)
    devices:
      - "/dev/i2c-1:/dev/i2c-1" # <--- DIREKTE MAP AN DIE SERVOS
    environment:
      - ROS_DOMAIN_ID=0
      #- FASTRTPS_DEFAULT_PROFILES_FILE=/ros2_ws/pi_discovery_fix.xml # <--- XML laden
      #- ROS_DISCOVERY_SERVER=127.0.0.1:11811
      #- PYTHONPATH=/ros2_ws:/ros2_ws/Server
      # ------------------
      # Wir löschen ROS_DISCOVERY_SERVER!
      # Stattdessen sagen wir ihm, er soll nur auf sich selbst und später auf den PC hören:
      - RMW_IMPLEMENTATION=rmw_fastrtps_cpp
      #- FASTRTPS_DEFAULT_PROFILES_FILE=/ros2_ws/pi_unicast_only.xml
      - PYTHONPATH=/ros2_ws:/ros2_ws/Server
      # ------------------
      # Wir sagen dem Pi, er soll den PC direkt anrufen:
      #- ROS_STATIC_PEERS=192.168.2.121  # <--- HIER DEINE NOTIERTE IP EINTRAGEN
      - ROS_DISCOVERY_SERVER=192.168.2.121:11811
      #- FASTRTPS_DEFAULT_PROFILES_FILE=/ros2_ws/pi_static_peers.xml  # <--- HIER DEINE NOTIERTE IP EINTRAGEN
    #depends_on:
    #  discovery-server:
    #    condition: service_healthy  # Warte bis Server wirklich bereit ist
    volumes:
      - /home/pi/adeept_raspclaws:/ros2_ws
      - /dev:/dev  # Gibt dem Container direkten Zugriff auf Kamera und I2C
    command: >
      bash -c "source /opt/ros/humble/setup.bash && 
            python3 /ros2_ws/Server/ROSServer.py"
    restart: always
    healthcheck:
      #test: ["CMD", "ros2", "topic", "list"]
      test: >
        bash -c "source /opt/ros/humble/setup.bash &&
        ros2 topic list >/dev/null"
      interval: 5s
      timeout: 15s
      retries: 10

  #raspclaws_camera:
  #  image: adeept_raspclaws-raspclaws_ros2:latest  # Gleiches Image wie raspclaws_ros2
  #  build:
  # Camera container - starts both FPV.py (camera capture) and FPV_ROS2_simple.py (ROS2 publisher)
  # FPV.py handles camera hardware and provides frames via ZMQ
  # FPV_ROS2_simple.py reads those frames and publishes to ROS2 topics
  # Camera container - publishes camera frames to ROS2 topics
  # OPTIONAL: Only needed if you want camera stream in ROS2
  # Disable this if no camera is connected
  raspclaws_camera:
    image: adeept_raspclaws-raspclaws_ros2:latest
    depends_on:
      raspclaws_ros2:
          condition: service_healthy
    build:
      context: .
      dockerfile: Dockerfile.ros2
    container_name: raspclaws_camera
    network_mode: host  # ROS2 DDS braucht host network
    privileged: true    # Für Kamera-Zugriff
    # Map ALL camera-related devices
    devices:
      - /dev/video0:/dev/video0  # V4L2 camera device
      - /dev/video10:/dev/video10  # ISP device (if exists)
      - /dev/video11:/dev/video11  # ISP device (if exists)
      - /dev/video12:/dev/video12  # ISP device (if exists)
      - /dev/video13:/dev/video13  # ISP device (if exists)
      - /dev/video14:/dev/video14  # ISP device (if exists)
      - /dev/video15:/dev/video15  # ISP device (if exists)
      - /dev/video16:/dev/video16  # ISP device (if exists)
      - /dev/media0:/dev/media0    # Media controller
      - /dev/media1:/dev/media1    # Media controller (if exists)
      - /dev/media2:/dev/media2    # Media controller (if exists)
      - /dev/media3:/dev/media3    # Media controller (if exists)
    environment:
      - ROS_DOMAIN_ID=0  # Gleiche Domain wie raspclaws_ros2
      - RMW_IMPLEMENTATION=rmw_fastrtps_cpp
      - PYTHONPATH=/ros2_ws:/ros2_ws/Server
      #- ROS_STATIC_PEERS=192.168.2.121  # <--- HIER DEINE NOTIERTE IP EINTRAGEN
      - ROS_DISCOVERY_SERVER=192.168.2.121:11811
      #- FASTRTPS_DEFAULT_PROFILES_FILE=/ros2_ws/pi_static_peers.xml  # Gleicher PC wie raspclaws_ros2
      # libcamera environment variables
      - LIBCAMERA_LOG_LEVELS=*:ERROR  # Reduce log spam
    volumes:
      - /home/pi/adeept_raspclaws:/ros2_ws
      - /dev:/dev  # Gibt dem Container direkten Zugriff auf alle Devices
      - /sys:/sys  # Für Hardware-Erkennung
      - /run/udev:/run/udev:ro  # udev rules (readonly)
    command: >
      bash -c "source /opt/ros/humble/setup.bash && 
            ros2 launch /ros2_ws/launch/camera.launch.py"
    # Only restart if container crashes (exit code != 0)
    # Will NOT restart if camera is not available (script sleeps with exit 0)
    restart: on-failure

